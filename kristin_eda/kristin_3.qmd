---
title: "Tone Analysis of Fox News Coverage"
author: "Kristin Lloyd"
format: 
  html:
    embed-resources: true
    code-fold: true
---

## ðŸ“¥ Data Import and Cleaning

```{python}
import pandas as pd
import glob
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from collections import Counter
from scipy.stats import ttest_ind
import matplotlib.dates as mdates

# Load all fox CSV files
csv_files = glob.glob("../data/fox/fox*.csv")
df = pd.concat([pd.read_csv(file) for file in csv_files], ignore_index=True)

# Select relevant columns
columns_of_interest = [
    "parsed_date", "url", "headline_from_url",
    "V2Themes", "V2Locations", "V2Persons",
    "V2Organizations", "V2Tone"
]
df = df[columns_of_interest]

# Convert parsed_date to datetime and ensure it's timezone-naive
df["parsed_date"] = pd.to_datetime(df["parsed_date"], errors="coerce").dt.tz_localize(None)

# Preview structure and missing values
print("DataFrame structure and missing values:")
df.info()
print("\nMissing values count:")
print(df.isnull().sum())
print("\nSample data:")
print(df.sample(5))
```

## Tone Score Processing

```{python}
# Split V2Tone into tone, positive_score, and negative_score
tone_split = df["V2Tone"].str.split(",", expand=True)
df["tone"] = pd.to_numeric(tone_split[0], errors="coerce")
df["positive_score"] = pd.to_numeric(tone_split[1], errors="coerce")
df["negative_score"] = pd.to_numeric(tone_split[2], errors="coerce")

# Descriptive stats for tone metrics
print("Tone descriptive statistics:")
print(df["tone"].describe())
print("\nPositive score descriptive statistics:")
print(df["positive_score"].describe())
print("\nNegative score descriptive statistics:")
print(df["negative_score"].describe())
```

## Tone Trend Analysis

```{python}
# Create year-month column and compute trends
df["year_month"] = df["parsed_date"].dt.to_period("M")
tone_trend = df.groupby("year_month")["tone"].mean().reset_index()
tone_trend["year_month"] = pd.to_datetime(tone_trend["year_month"].astype(str))
tone_trend["rolling_avg"] = tone_trend["tone"].rolling(window=3, center=True).mean()

# Plot tone trend
plt.figure(figsize=(14, 6))
plt.plot(tone_trend["year_month"], tone_trend["tone"], alpha=0.3, label='Monthly Average')
plt.plot(tone_trend["year_month"], tone_trend["rolling_avg"], color='red', label='3-Month Rolling Avg', linewidth=2)
plt.title("Average Tone Over Time (Monthly, with Smoothing)", fontsize=14)
plt.xlabel("Month")
plt.ylabel("Average Tone")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```

The monthly average shows short-term tone shifts, while the 3-month rolling average smooths out volatility and reveals broader sentiment trends.

## Election Influence on Media Tone

U.S. elections can shape media tone dramatically due to increased political coverage and polarization.

- 2016 Presidential: Highly divisive race may have driven negative coverage.
- 2018 Midterms: Conflict-heavy narratives around congressional power shifts.
- 2020 Presidential: COVID, mail-in voting, and election denial dominated tone.
- 2022 Midterms: Continued division and debate over policy issues.
- 2024 Presidential: Early campaign portrayals of Trump likely influenced tone.

## Visualizing Election and COVID Impact

```{python}
# Define key U.S. elections and COVID emergence
election_events = {
    "2016 Presidential": "2016-11-08",
    "2018 Midterms": "2018-11-06",
    "2020 Presidential": "2020-11-03",
    "2022 Midterms": "2022-11-08",
    "2024 Presidential": "2024-11-05",
    "COVID": "2020-03-10"
}
event_dates = {label: pd.to_datetime(date) for label, date in election_events.items()}

# Plot with election overlays
plt.figure(figsize=(14, 6))
plt.plot(tone_trend["year_month"], tone_trend["tone"], alpha=0.3, label='Monthly Average')
plt.plot(tone_trend["year_month"], tone_trend["rolling_avg"], color='red', label='3-Month Rolling Avg', linewidth=2)

# Draw event lines
for label, date in event_dates.items():
    plt.axvline(date, color='blue', linestyle='--', alpha=0.7)
    plt.text(date, tone_trend["tone"].min() + 0.2, label, rotation=90, verticalalignment='bottom', fontsize=8)

plt.title("Average Tone Over Time (Monthly, with Elections Overlayed)", fontsize=14)
plt.xlabel("Month")
plt.ylabel("Average Tone")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()
```

## Election Tone Shift Analysis

```{python}
# Define U.S. election dates
election_dates = {
    "2016 Presidential": pd.to_datetime("2016-11-08"),
    "2018 Midterms": pd.to_datetime("2018-11-06"),
    "2020 Presidential": pd.to_datetime("2020-11-03"),
    "2022 Midterms": pd.to_datetime("2022-11-08"),
    "2024 Presidential": pd.to_datetime("2024-11-05")
}

# Analyze tone before vs. after each election
results = []
for label, date in election_dates.items():
    pre = df[(df["parsed_date"] >= date - pd.DateOffset(months=3)) & (df["parsed_date"] < date)]
    post = df[(df["parsed_date"] >= date) & (df["parsed_date"] < date + pd.DateOffset(months=3))]

    results.append({
        "election": label,
        "pre_avg_tone": pre["tone"].mean(),
        "post_avg_tone": post["tone"].mean(),
        "tone_shift": post["tone"].mean() - pre["tone"].mean()
    })

# Create results DataFrame
tone_shift_df = pd.DataFrame(results)
print("Tone shifts before and after elections:")
print(tone_shift_df)

# Setup for bar plot
labels = tone_shift_df["election"]
x = np.arange(len(labels))
width = 0.35

plt.figure(figsize=(10, 6))
bars1 = plt.bar(x - width/2, tone_shift_df["pre_avg_tone"], width, label='3 Months Before')
bars2 = plt.bar(x + width/2, tone_shift_df["post_avg_tone"], width, label='3 Months After')

plt.ylabel("Average Tone")
plt.title("Average Tone Before vs. After U.S. Elections")
plt.xticks(x, labels, rotation=45, ha="right")
plt.axhline(0, color='black', linewidth=0.5)
plt.legend()
plt.grid(axis='y', linestyle='--', alpha=0.5)

# Annotate tone shift on top
for i in range(len(x)):
    shift = tone_shift_df["tone_shift"].iloc[i]
    plt.text(x[i], max(tone_shift_df["pre_avg_tone"].iloc[i], tone_shift_df["post_avg_tone"].iloc[i]) + 0.1,
             f"+{shift:.2f}" if shift > 0 else f"{shift:.2f}", 
             ha='center', fontsize=9, color='green' if shift > 0 else 'red')

plt.tight_layout()
plt.show()
```

The tone values in GDELT typically range from â€“10 to +10, but most news content clusters between â€“5 and +1.

Your tone mean is around â€“2.7, so a +0.3 shift is a ~11% relative change, which is meaningful in sentiment analysis terms â€” especially across tens of thousands of articles.

All 5 elections showed a positive shift â€” even if modest, that pattern suggests a reliable directional trend, not random fluctuation.

## Statistical Significance Testing

```{python}
# Perform t-tests for statistical significance
print("Statistical significance of tone shifts (t-test):")
for label, date in election_dates.items():
    pre = df[(df["parsed_date"] >= date - pd.DateOffset(months=3)) & (df["parsed_date"] < date)]["tone"].dropna()
    post = df[(df["parsed_date"] >= date) & (df["parsed_date"] < date + pd.DateOffset(months=3))]["tone"].dropna()
    
    t_stat, p_val = ttest_ind(post, pre, equal_var=False)
    print(f"{label}: t-statistic = {t_stat:.4f}, p-value = {p_val:.4f}")
```

## Theme Analysis

```{python}
# Drop missing themes and split by semicolon
themes_series = df["V2Themes"].dropna().str.split(";")

# Flatten the list of all theme entries
all_themes = [theme.split(",")[0] for sublist in themes_series for theme in sublist if theme]

# Count the most frequent themes
theme_counts = Counter(all_themes).most_common(20)

# Print top themes
print("Top 20 Most Common Themes:")
for theme, count in theme_counts:
    print(f"{theme}: {count}")
```

## Theme Shifts Before and After Elections

```{python}
# Function to get theme counts in a specific date range
def get_theme_counts(start_date, end_date):
    mask = (df["parsed_date"] >= start_date) & (df["parsed_date"] <= end_date)
    themes_series = df.loc[mask, "V2Themes"].dropna().str.split(";")
    all_themes = [theme.split(",")[0] for sublist in themes_series for theme in sublist if theme]
    return Counter(all_themes)

# Analyze themes before and after each election
theme_shift_analysis = {}
theme_shift_data = []  # Create a list to store data for the DataFrame

for election, date in election_dates.items():
    pre_start = date - pd.DateOffset(months=3)
    pre_end = date - pd.DateOffset(days=1)
    post_start = date + pd.DateOffset(days=1)
    post_end = date + pd.DateOffset(months=3)

    pre_counts = get_theme_counts(pre_start, pre_end)
    post_counts = get_theme_counts(post_start, post_end)

    # Calculate the difference in theme frequencies
    theme_diff = {theme: post_counts[theme] - pre_counts.get(theme, 0) for theme in post_counts}

    # Sort themes by the magnitude of change
    sorted_theme_diff = sorted(theme_diff.items(), key=lambda item: abs(item[1]), reverse=True)
    
    # Store top 10 themes with the most change
    theme_shift_analysis[election] = sorted_theme_diff[:10]
    
    # Add to the data list for DataFrame
    for theme, shift in sorted_theme_diff[:10]:
        theme_shift_data.append({
            "Election": election,
            "Theme": theme,
            "Tone Shift": shift
        })

# Create theme_df from the collected data
theme_df = pd.DataFrame(theme_shift_data)

# Display the results
for election, changes in theme_shift_analysis.items():
    print(f"\nTop Theme Changes for {election}:")
    for theme, change in changes:
        print(f"{theme}: {'+' if change > 0 else ''}{change}")
```

## Theme Name Cleanup and Visualization

```{python}
# Full theme mapping with cleaner names
theme_name_mapping = {
    "LEADER": "Leaders",
    "TAX_FNCACT_PRESIDENT": "Presidents",
    "USPEC_POLITICS_GENERAL1": "General Politics",
    "IMMIGRATION": "Immigration",
    "WB_2769_JOBS_STRATEGIES": "Job Strategies",
    "WB_2837_IMMIGRATION": "Immigration (WB)",
    "WB_2836_MIGRATION_POLICIES_AND_JOBS": "Migration Policies",
    "WB_2670_JOBS": "Jobs",
    "EPU_CATS_MIGRATION_FEAR_MIGRATION": "Migration Fear",
    "GENERAL_GOVERNMENT": "Government",
    "BORDER": "Border",
    "CRISISLEX_CRISISLEXREC": "Crisis Reporting",
    "NATURAL_DISASTER_HURRICANE": "Hurricanes",
    "TAX_WORLDMAMMALS_FOX": "Fox News (Self)",
    "EPU_POLICY_GOVERNMENT": "Government Policy",
    "TAX_FNCACT_POLICE": "Police",
    "UNGP_CRIME_VIOLENCE": "Crime & Violence",
    "HEALTH_VACCINATION": "Vaccination",
    "WB_639_REPRODUCTIVE_MATERNAL_AND_CHILD_HEALTH": "Reproductive & Child Health",
    "WB_642_CHILD_HEALTH": "Child Health",
    "WB_1459_IMMUNIZATIONS": "Immunizations",
    "UNGP_HEALTHCARE": "Healthcare (UNGP)",
    "TAX_FNCACT_NOMINEE": "Nominees",
    "MEDIA_SOCIAL": "Social Media",
    "ELECTION": "Election",
    "ECON_INFLATION": "Inflation",
    "WB_1104_MACROECONOMIC_VULNERABILITY_AND_DEBT": "Macro Vulnerability & Debt",
    "WB_442_INFLATION": "Inflation (WB)",
    "TAX_POLITICAL_PARTY_DEMOCRATS": "Democrats",
    "TAX_FNCACT_QUEEN": "Queen",
    "TAX_FNCACT_VICE_PRESIDENT": "Vice Presidents",
    "CRISISLEX_C07_SAFETY": "Safety",
    "MANMADE_DISASTER_IMPLIED": "Manmade Disaster",
    "WB_2432_FRAGILITY_CONFLICT_AND_VIOLENCE": "Conflict & Fragility"
}

# Apply renaming to the theme DataFrame
theme_df["Theme"] = theme_df["Theme"].map(lambda x: theme_name_mapping.get(x, x))

# Show cleaned theme list
print("Sample of cleaned theme data:")
print(theme_df.head(10))
```

## shift 3 months before to 3 months after

```{python}
# Create pivot table for heatmap
pivot_df = theme_df.pivot(index="Theme", columns="Election", values="Tone Shift").fillna(0)

# Overall heatmap
plt.figure(figsize=(12, 10))
sns.heatmap(pivot_df, cmap="RdBu_r", center=0, annot=True, fmt=".0f", linewidths=0.5)
plt.title("Theme Tone Shift Across Elections")
plt.ylabel("Theme")
plt.xlabel("Election")
plt.tight_layout()
plt.show()

# Individual election heatmaps
unique_elections = theme_df["Election"].unique()

for election in unique_elections:
    # Filter for this election and create a pivot table
    election_df = theme_df[theme_df["Election"] == election]
    single_df = election_df.pivot(index="Theme", columns="Election", values="Tone Shift").fillna(0)
    
    plt.figure(figsize=(6, 10))
    sns.heatmap(single_df, cmap="RdBu_r", center=0, annot=True, fmt=".0f", linewidths=0.5)
    plt.title(f"Theme Tone Shift â€“ {election}")
    plt.xlabel("Election")
    plt.ylabel("Theme")
    plt.tight_layout()
    plt.show()
```

## Theme Shift from 3 months before to 6 months after

```{python}
# Create pivot table for heatmap
pivot_df = theme_df.pivot(index="Theme", columns="Election", values="Tone Shift").fillna(0)

# Overall heatmap
plt.figure(figsize=(12, 10))
sns.heatmap(pivot_df, cmap="RdBu_r", center=0, annot=True, fmt=".0f", linewidths=0.5)
plt.title("Theme Tone Shift Across Elections")
plt.ylabel("Theme")
plt.xlabel("Election")
plt.tight_layout()
plt.show()

# Individual election heatmaps
unique_elections = theme_df["Election"].unique()

for election in unique_elections:
    # Filter for this election and create a pivot table
    election_df = theme_df[theme_df["Election"] == election]
    single_df = election_df.pivot(index="Theme", columns="Election", values="Tone Shift").fillna(0)
    
    plt.figure(figsize=(6, 10))
    sns.heatmap(single_df, cmap="RdBu_r", center=0, annot=True, fmt=".0f", linewidths=0.5)
    plt.title(f"Theme Tone Shift â€“ {election}")
    plt.xlabel("Election")
    plt.ylabel("Theme")
    plt.tight_layout()
    plt.show()
```

## Interpreting Heatmap Values

Y-axis (Theme):
Each row is a theme or topic extracted from news articles â€” like Immigration, Presidents, or Social Media.

X-axis (Election):
Each column represents a different election cycle.

Color:

ðŸ”´ Red = Less negative coverage after the election

ðŸ”µ Blue = Less positive coverage after the election

White = No change

Cell Value (Number):
The numerical tone shift â€” e.g., +834 means tone became more positive; -1530 means more negative.










## JUST before the election on Theme Analysis

```{python}
# Visualize most common themes 3 months before each election
plt.figure(figsize=(15, 12))

# Define a colormap for consistent colors
colors = plt.cm.tab20(np.linspace(0, 1, len(election_dates)))
color_idx = 0

# Create subplot grid
fig, axes = plt.subplots(len(election_dates), 1, figsize=(12, 4*len(election_dates)))
fig.tight_layout(pad=5.0)

# For each election, get the most common themes in the 3 months before
for i, (election, date) in enumerate(election_dates.items()):
    pre_start = date - pd.DateOffset(months=3)
    pre_end = date - pd.DateOffset(days=1)
    
    # Get themes for this time period
    mask = (df["parsed_date"] >= pre_start) & (df["parsed_date"] <= pre_end)
    pre_themes_series = df.loc[mask, "V2Themes"].dropna().str.split(";")
    
    # Extract and count themes
    pre_themes = [theme.split(",")[0] for sublist in pre_themes_series for theme in sublist if theme]
    pre_theme_counts = Counter(pre_themes).most_common(10)  # Top 10 themes
    
    # Map to friendly names
    friendly_names = [(theme_name_mapping.get(theme, theme), count) for theme, count in pre_theme_counts]
    
    # Create DataFrame for this election
    theme_df_election = pd.DataFrame(friendly_names, columns=['Theme', 'Count'])
    
    # Plot horizontal bar chart
    ax = axes[i]
    bars = ax.barh(theme_df_election['Theme'], theme_df_election['Count'], color=colors[color_idx:color_idx+len(theme_df_election)])
    color_idx = (color_idx + len(theme_df_election)) % len(colors)
    
    # Add count labels to bars
    for bar in bars:
        width = bar.get_width()
        ax.text(width + 5, bar.get_y() + bar.get_height()/2, 
                f'{width:,.0f}', ha='left', va='center')
    
    # Set titles and labels
    ax.set_title(f"Top Themes 3 Months Before {election}", fontsize=14)
    ax.set_xlabel('Count')
    ax.invert_yaxis()  # To have highest count at the top
    
    # Add gridlines
    ax.grid(axis='x', linestyle='--', alpha=0.7)

plt.suptitle("Most Common Themes in the 3 Months Before Each Election", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

```

## JUST after the election

## Post-Election Theme Analysis

```{python}
# Visualize most common themes 3 months after each election
plt.figure(figsize=(15, 12))

# Define a colormap for consistent colors
colors = plt.cm.tab20(np.linspace(0, 1, len(election_dates)))
color_idx = 0

# Create subplot grid
fig, axes = plt.subplots(len(election_dates), 1, figsize=(12, 4*len(election_dates)))
fig.tight_layout(pad=5.0)

# For each election, get the most common themes in the 3 months after
for i, (election, date) in enumerate(election_dates.items()):
    post_start = date + pd.DateOffset(days=1)
    post_end = date + pd.DateOffset(months=3)
    
    # Get themes for this time period
    mask = (df["parsed_date"] >= post_start) & (df["parsed_date"] <= post_end)
    post_themes_series = df.loc[mask, "V2Themes"].dropna().str.split(";")
    
    # Extract and count themes
    post_themes = [theme.split(",")[0] for sublist in post_themes_series for theme in sublist if theme]
    post_theme_counts = Counter(post_themes).most_common(10)  # Top 10 themes
    
    # Map to friendly names
    friendly_names = [(theme_name_mapping.get(theme, theme), count) for theme, count in post_theme_counts]
    
    # Create DataFrame for this election
    theme_df_election = pd.DataFrame(friendly_names, columns=['Theme', 'Count'])
    
    # Plot horizontal bar chart
    ax = axes[i]
    bars = ax.barh(theme_df_election['Theme'], theme_df_election['Count'], color=colors[color_idx:color_idx+len(theme_df_election)])
    color_idx = (color_idx + len(theme_df_election)) % len(colors)
    
    # Add count labels to bars
    for bar in bars:
        width = bar.get_width()
        ax.text(width + 5, bar.get_y() + bar.get_height()/2, 
                f'{width:,.0f}', ha='left', va='center')
    
    # Set titles and labels
    ax.set_title(f"Top Themes 3 Months After {election}", fontsize=14)
    ax.set_xlabel('Count')
    ax.invert_yaxis()  # To have highest count at the top
    
    # Add gridlines
    ax.grid(axis='x', linestyle='--', alpha=0.7)

plt.suptitle("Most Common Themes in the 3 Months After Each Election", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

```

## 6 months after

## Extended Post-Election Theme Analysis (6 Months)

```{python}
# Visualize most common themes for the full 6 months after each election
plt.figure(figsize=(15, 12))

# Define a colormap for consistent colors
colors = plt.cm.tab20(np.linspace(0, 1, len(election_dates)))
color_idx = 0

# Create subplot grid
fig, axes = plt.subplots(len(election_dates), 1, figsize=(12, 4*len(election_dates)))
fig.tight_layout(pad=5.0)

# For each election, get the most common themes in the 6 months after
for i, (election, date) in enumerate(election_dates.items()):
    post_start = date + pd.DateOffset(days=1)        # Start right after election
    post_end = date + pd.DateOffset(months=6)        # End at 6 months post-election
    
    # Get themes for this time period
    mask = (df["parsed_date"] >= post_start) & (df["parsed_date"] <= post_end)
    post_themes_series = df.loc[mask, "V2Themes"].dropna().str.split(";")
    
    # Extract and count themes
    post_themes = [theme.split(",")[0] for sublist in post_themes_series for theme in sublist if theme]
    post_theme_counts = Counter(post_themes).most_common(10)  # Top 10 themes
    
    # Map to friendly names
    friendly_names = [(theme_name_mapping.get(theme, theme), count) for theme, count in post_theme_counts]
    
    # Create DataFrame for this election
    theme_df_election = pd.DataFrame(friendly_names, columns=['Theme', 'Count'])
    
    # Plot horizontal bar chart
    ax = axes[i]
    bars = ax.barh(theme_df_election['Theme'], theme_df_election['Count'], color=colors[color_idx:color_idx+len(theme_df_election)])
    color_idx = (color_idx + len(theme_df_election)) % len(colors)
    
    # Add count labels to bars
    for bar in bars:
        width = bar.get_width()
        ax.text(width + 5, bar.get_y() + bar.get_height()/2, 
                f'{width:,.0f}', ha='left', va='center')
    
    # Set titles and labels
    ax.set_title(f"Top Themes 6 Months After {election}", fontsize=14)
    ax.set_xlabel('Count')
    ax.invert_yaxis()  # To have highest count at the top
    
    # Add gridlines
    ax.grid(axis='x', linestyle='--', alpha=0.7)

plt.suptitle("Most Common Themes in the 6 Months After Each Election", fontsize=16, y=1.02)
plt.tight_layout()
plt.show()

```