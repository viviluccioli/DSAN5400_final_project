---
title: "News Network Tone Analysis"
author: "Kristin Lloyd"
format: 
  html:
    embed-resources: true
    code-fold: true
    toc: true
    toc-depth: 3
    toc-title: "Contents"
    code-tools: true
    error: false  
---

# Tone Analysis

This document analyzes tone differences across three major news networks: Fox News, ABC News, and MSNBC. Using data from multiple sources, we examine how tone metrics vary between networks and what this might tell us about their reporting styles.

## Data Processing and Methodology

```{python}
#| echo: false

import pandas as pd
import glob
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from collections import Counter
from scipy.stats import ttest_ind
import matplotlib.dates as mdates

plt.style.use('seaborn-v0_8-whitegrid')
plt.rcParams['font.family'] = 'sans-serif'
plt.rcParams['font.sans-serif'] = ['Arial', 'DejaVu Sans', 'Liberation Sans']

# Import data files
csv_files = (
    glob.glob("../data/fox/fox*.csv") +
    glob.glob("../data/abc/abc*.csv") +
    glob.glob("../data/msnbc/msnbc*.csv")
)

df = pd.concat([pd.read_csv(file) for file in csv_files], ignore_index=True)

# Select relevant columns
columns_of_interest = [
    "parsed_date", "url", "headline_from_url",
    "V2Themes", "V2Locations", "V2Persons",
    "V2Organizations", "V2Tone"
]
df = df[columns_of_interest]

# Convert date and extract network information
df["parsed_date"] = pd.to_datetime(df["parsed_date"], errors="coerce").dt.tz_localize(None)

# Extract network source from URLs
def extract_network(url):
    if 'fox' in url.lower():
        return 'Fox News'
    elif 'abc' in url.lower():
        return 'ABC News'
    elif 'msnbc' in url.lower():
        return 'MSNBC'
    else:
        return 'Unknown'

# Add network column
df['network'] = df['url'].apply(extract_network)
```

## Overview of Dataset

why is msnbc missing so many???

Before diving into tone analysis, let's examine our dataset composition by network:

```{python}
#| echo: false
#| label: fig-article-count
#| fig-cap: "Number of articles analyzed by network"

article_counts = df.groupby('network').size()
print("\nNumber of Articles Analyzed by Network:")
display(article_counts)

plt.figure(figsize=(10, 6))
article_counts.plot(kind='bar', color='#64C1FF')
plt.title('Number of Articles by News Network', fontsize=14, fontweight='bold')
plt.xlabel('News Network')
plt.ylabel('Number of Articles')
plt.xticks(rotation=45)
plt.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.show()
```

## Tone Score Distribution

The following visualization compares the distribution of tone scores across the three networks:

```{python}

#| echo: false
#| label: fig-pos-neg-comparison
#| fig-cap: "Comparison of average positive and negative scores by network"

if 'positive_score' not in df.columns or 'negative_score' not in df.columns:
    tone_split = df["V2Tone"].str.split(",", expand=True)
    df["tone"] = pd.to_numeric(tone_split[0], errors="coerce")
    df["positive_score"] = pd.to_numeric(tone_split[1], errors="coerce")
    df["negative_score"] = pd.to_numeric(tone_split[2], errors="coerce")

df_filtered = df.dropna(subset=['positive_score', 'negative_score'])

avg_scores = df_filtered.groupby('network')[['positive_score', 'negative_score']].mean().reset_index()

```

```{python}
#| echo: false
#| label: fig-tone-boxplot
#| fig-cap: "Tone distribution boxplot comparison between networks"

plt.figure(figsize=(12, 8))
sns.boxplot(x='network', y='tone', data=df, palette='Set2')
plt.axhline(y=0, color='black', linestyle='--', alpha=0.7, label='Neutral Tone')
plt.title('Tone Score Distribution', fontsize=16, fontweight='bold')
plt.xlabel('News Network', fontsize=12)
plt.ylabel('Tone Score', fontsize=12)
plt.grid(axis='y', alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()
```

## Positive vs Negative Component Analysis

To better understand the tone composition, we analyze the positive and negative components separately: (can change this to our own sentiment analysis)

```{python}
#| echo: false
#| label: fig-pos-neg-comparison
#| fig-cap: "Comparison of average positive and negative scores by network"

avg_scores = df.groupby('network')[['positive_score', 'negative_score']].mean().reset_index()

plt.figure(figsize=(12, 8))
bar_width = 0.35
x = np.arange(len(avg_scores))

plt.bar(x - bar_width/2, avg_scores['positive_score'], bar_width, label='Positive Score', color='forestgreen', alpha=0.7)
plt.bar(x + bar_width/2, avg_scores['negative_score'], bar_width, label='Negative Score', color='firebrick', alpha=0.7)

plt.xticks(x, avg_scores['network'], fontsize=12)
plt.title('Average Positive vs Negative Scores by Network', fontsize=16, fontweight='bold')
plt.xlabel('News Network', fontsize=12)
plt.ylabel('Average Score', fontsize=12)
plt.legend()
plt.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.show()
```

## Statistical Analysis

```{python}
#| echo: false
#| label: tbl-tone-stats
#| tbl-cap: "Tone analysis summary statistics by network"

tone_stats = df.groupby('network')['tone'].agg(['mean', 'std', 'median', 'min', 'max']).round(2)
pos_stats = df.groupby('network')['positive_score'].agg(['mean', 'std']).round(2)
neg_stats = df.groupby('network')['negative_score'].agg(['mean', 'std']).round(2)

summary_stats = pd.DataFrame({
    'Mean Tone': tone_stats['mean'],
    'Median Tone': tone_stats['median'],
    'Tone Std Dev': tone_stats['std'],
    'Min Tone': tone_stats['min'],
    'Max Tone': tone_stats['max'],
    'Mean Positive Score': pos_stats['mean'],
    'Mean Negative Score': neg_stats['mean']
})

summary_stats
```

## Statistical Significance Testing

```{python}
#| echo: false
#| label: tbl-significance-tests
#| tbl-cap: "Statistical significance of tone differences between networks"

print("Statistical Significance Testing (t-test for tone differences):")
networks = df['network'].unique()

significance_results = []

for i in range(len(networks)):
    for j in range(i+1, len(networks)):
        network1 = networks[i]
        network2 = networks[j]
        tone1 = df[df['network'] == network1]['tone']
        tone2 = df[df['network'] == network2]['tone']
        
        t_stat, p_val = ttest_ind(tone1, tone2, equal_var=False)
        
        # Add to results
        significance_results.append({
            'Comparison': f"{network1} vs {network2}",
            't-statistic': round(t_stat, 4),
            'p-value': round(p_val, 4),
            'Significant': 'Yes' if p_val < 0.05 else 'No'
        })

significance_df = pd.DataFrame(significance_results)
display(significance_df)
```

## Temporal Analysis

Let's examine how tone varies over time for each network:

```{python}

#| echo: false
#| label: fig-tone-time-series
#| fig-cap: "Monthly average tone trends by news network"

# Resample by month for each network
df['month'] = df['parsed_date'].dt.to_period('M')

# Calculate monthly average tone for each network
monthly_tone = df.groupby(['month', 'network'])['tone'].mean().unstack()

# Plot time series
plt.figure(figsize=(14, 8))
for column in monthly_tone.columns:
    plt.plot(monthly_tone.index.astype(str), monthly_tone[column], marker='o', markersize=5, linewidth=2, label=column)

# Convert index to strings for x-axis
x_labels = monthly_tone.index.astype(str)

# Create a list to store positions for tick marks (every 6 months)
tick_positions = []
tick_labels = []

# Identify every 6th month for tick marks
for i, date_str in enumerate(x_labels):
    # Check if it's a January or July (months 1 or 7)
    if date_str.endswith('-01') or date_str.endswith('-07'):
        tick_positions.append(i)
        tick_labels.append(date_str)

plt.axhline(y=0, color='black', linestyle='--', alpha=0.5, label='Neutral Tone')
plt.title('Monthly Average Tone by News Network', fontsize=16, fontweight='bold')
plt.xlabel('Month', fontsize=12)
plt.ylabel('Average Tone Score', fontsize=12)
plt.grid(alpha=0.3)
plt.legend()

# Set tick positions and labels
plt.xticks(tick_positions, tick_labels, rotation=45)
plt.tight_layout()
plt.show()

```

can add trump elected, biden elected, trump elected, covid, 

```{python}

#| echo: false
#| label: fig-tone-time-series
#| fig-cap: "Monthly average tone trends by news network"
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.dates as mdates
from matplotlib.ticker import MaxNLocator

# Create month period for grouping
df['month'] = df['parsed_date'].dt.to_period('M')

# Calculate monthly average tone for each network
monthly_tone = df.groupby(['month', 'network'])['tone'].mean().unstack()

# Plot time series
plt.figure(figsize=(14, 8))
for column in monthly_tone.columns:
    plt.plot(monthly_tone.index.astype(str), monthly_tone[column], marker='o', markersize=5, linewidth=2, label=column)

# Convert index to strings for x-axis
x_labels = monthly_tone.index.astype(str)

# Create a list to store positions for tick marks (every 6 months)
tick_positions = []
tick_labels = []

# Identify every 6th month for tick marks (January and July)
for i, date_str in enumerate(x_labels):
    if date_str.endswith('-01') or date_str.endswith('-07'):
        tick_positions.append(i)
        tick_labels.append(date_str)

# Add reference line for neutral tone
plt.axhline(y=0, color='black', linestyle='--', alpha=0.5, label='Neutral Tone')

# Improve visual presentation
plt.title('Monthly Average Tone by News Network', fontsize=16, fontweight='bold')
plt.xlabel('Month', fontsize=12)
plt.ylabel('Average Tone Score', fontsize=12)
plt.grid(alpha=0.3)
plt.legend(loc='best', frameon=True, framealpha=0.9)

# Set tick positions and labels
plt.xticks(tick_positions, tick_labels, rotation=45)

# Add annotations for significant events
# Modify these dates and positions based on your actual data
events = {
    '2016-11': ('Trump Elected', 0.2),   # You mentioned "trump elected"
    '2020-01': ('COVID-19 Begins', 0.1),  # You mentioned "covid"
    '2020-11': ('Biden Elected', 0.3),    # You mentioned "biden elected"
    '2024-11': ('Trump Re-Elected', 0.4)  # You mentioned "trump elected" twice
}

# Add vertical lines and annotations for key events
# Only add events that fall within your data range
for date, (event_name, offset) in events.items():
    if date in x_labels:
        idx = list(x_labels).index(date)
        plt.axvline(x=idx, color='red', linestyle=':', alpha=0.7)
        # Find a y-position that works with your data
        # This will need adjustment based on your actual tone values
        y_pos = monthly_tone.iloc[idx].max() + offset
        plt.annotate(event_name, xy=(idx, y_pos), xytext=(idx+1, y_pos),
                    arrowprops=dict(facecolor='red', shrink=0.05, width=1.5, headwidth=8),
                    fontsize=10, fontweight='bold')

plt.tight_layout()
plt.savefig('news_tone_trends.png', dpi=300)  # Save high-resolution image
plt.show()

```

```{python}

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from matplotlib.ticker import MaxNLocator

# Define key event dates
events = {
    "Trump Election 2016": "2016-11-08",
    "COVID-19 Onset": "2020-01-20",  # Using approximate start of COVID news coverage
    "Biden Election 2020": "2020-11-03",
    "Trump Election 2024": "2024-11-05"
}

# Function to calculate average tone before and after an event
def calculate_tone_change(df, event_date, window_months=3):
    """Calculate tone change from before to after an event"""
    # Convert string date to datetime
    event_date = pd.to_datetime(event_date)
    
    # Define time windows
    before_start = event_date - pd.DateOffset(months=window_months)
    after_end = event_date + pd.DateOffset(months=window_months)
    
    # Filter dataframe for the before and after periods
    before_df = df[(df['parsed_date'] >= before_start) & (df['parsed_date'] < event_date)]
    after_df = df[(df['parsed_date'] >= event_date) & (df['parsed_date'] < after_end)]
    
    # Calculate average tone by network before and after
    before_tone = before_df.groupby('network')['tone'].mean()
    after_tone = after_df.groupby('network')['tone'].mean()
    
    # Calculate the difference
    tone_change = pd.DataFrame({
        'before': before_tone,
        'after': after_tone
    })
    
    # Calculate the change
    tone_change['change'] = tone_change['after'] - tone_change['before']
    
    return tone_change

# Function to create a single event's visualization (for comparison)
def plot_tone_change_single_event(df, event_name, event_date, window_months=3):
    """Create a visualization for a single event's tone changes"""
    tone_change = calculate_tone_change(df, event_date, window_months)
    
    # Sort by the magnitude of change
    tone_change = tone_change.sort_values('change')
    
    # Plot
    plt.figure(figsize=(12, 8))
    
    # Plot bars for tone change
    bars = plt.barh(tone_change.index, tone_change['change'], 
                   color=[plt.cm.RdBu(0.1) if x < 0 else plt.cm.RdBu(0.9) for x in tone_change['change']])
    
    # Add a vertical line at 0
    plt.axvline(x=0, color='black', linestyle='-', alpha=0.3)
    
    # Add labels
    plt.title(f"Change in News Tone After {event_name} (±{window_months} months)", 
              fontsize=16, fontweight='bold')
    plt.xlabel('Tone Change (Positive values = More positive tone)', fontsize=12)
    plt.ylabel('News Network', fontsize=12)
    
    # Add value labels with + or - signs
    for bar in bars:
        width = bar.get_width()
        label_x = width + 0.01 if width > 0 else width - 0.01
        alignment = 'left' if width > 0 else 'right'
        # Add + sign for positive values
        sign = "+" if width > 0 else ""
        plt.text(label_x, bar.get_y() + bar.get_height()/2, 
                 f'{sign}{width:.2f}', 
                 ha=alignment, va='center', 
                 color='black', fontweight='bold')
    
    # Add grid
    plt.grid(axis='x', linestyle='--', alpha=0.3)
    
    # Remove top and right spines
    plt.gca().spines['top'].set_visible(False)
    plt.gca().spines['right'].set_visible(False)
    
    plt.tight_layout()
    return plt.gcf()

# Function to create a multi-event comparison
def plot_tone_change_comparison(df, events, window_months=3):
    """Create a visualization comparing tone changes across multiple events"""
    results = {}
    
    # Calculate changes for each event
    for event_name, event_date in events.items():
        try:
            # Skip events beyond our data range (like future events)
            event_date_dt = pd.to_datetime(event_date)
            max_date = df['parsed_date'].max()
            
            # Only process events within our data range
            if event_date_dt <= max_date:
                results[event_name] = calculate_tone_change(df, event_date, window_months)
        except Exception as e:
            print(f"Skipping {event_name} due to: {e}")
    
    # Create a figure with subplots
    fig, axes = plt.subplots(len(results), 1, figsize=(14, 4*len(results)), sharex=True)
    
    # If only one event, axes won't be a list
    if len(results) == 1:
        axes = [axes]
    
    # Get all networks for consistent ordering
    all_networks = set()
    for event_data in results.values():
        all_networks.update(event_data.index)
    
    # Sort networks by average change across all events
    network_avg_change = {}
    for network in all_networks:
        changes = []
        for event_data in results.values():
            if network in event_data.index:
                changes.append(event_data.loc[network, 'change'])
        network_avg_change[network] = np.mean(changes) if changes else 0
    
    # Sort networks by average change
    sorted_networks = sorted(network_avg_change.keys(), 
                            key=lambda x: network_avg_change[x])
    
    # Create each subplot
    for i, (event_name, event_data) in enumerate(results.items()):
        ax = axes[i]
        
        # Create a complete dataframe with all networks
        complete_data = pd.DataFrame(index=sorted_networks)
        complete_data['change'] = np.nan
        
        # Fill in available data
        for network in event_data.index:
            complete_data.loc[network, 'change'] = event_data.loc[network, 'change']
        
        # Plot horizontal bars
        colors = [plt.cm.RdBu(0.1) if x < 0 else plt.cm.RdBu(0.9) if x > 0 else 'lightgrey' 
                 for x in complete_data['change']]
        bars = ax.barh(complete_data.index, complete_data['change'], color=colors)
        
        # Add a vertical line at 0
        ax.axvline(x=0, color='black', linestyle='-', alpha=0.3)
        
        # Add title and labels
        ax.set_title(f"{event_name}", fontsize=14, fontweight='bold')
        ax.set_xlabel('Tone Change', fontsize=11)
        
        # Only add y-label for the middle plot
        if i == len(results) // 2:
            ax.set_ylabel('News Network', fontsize=12)
        
        # Add value labels with + or - signs
        for bar in bars:
            width = bar.get_width()
            if not np.isnan(width):  # Only add labels for non-NaN values
                label_x = width + 0.01 if width > 0 else width - 0.01
                alignment = 'left' if width > 0 else 'right'
                # Add + sign for positive values
                sign = "+" if width > 0 else ""
                ax.text(label_x, bar.get_y() + bar.get_height()/2, 
                         f'{sign}{width:.2f}', 
                         ha=alignment, va='center', 
                         color='black', fontweight='bold')
        
        # Add grid
        ax.grid(axis='x', linestyle='--', alpha=0.3)
        
        # Remove top and right spines
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
    
    # Add a common legend to the bottom
    fig.suptitle('News Tone Changes in 3 Months Following Major Events', fontsize=16, fontweight='bold', y=0.98)
    fig.text(0.5, 0.01, 'Negative Change = More Negative Coverage   |   Positive Change = More Positive Coverage', 
            ha='center', fontsize=12, fontstyle='italic')
    
    # Adjust layout
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.subplots_adjust(hspace=0.4)
    
    # Save the figure
    plt.savefig('news_tone_changes_after_events.png', dpi=300, bbox_inches='tight')
    
    return fig

# Alternative visualization: Heatmap of tone changes
def plot_tone_change_heatmap(df, events, window_months=3):
    """Create a heatmap visualization of tone changes across events and networks"""
    results = {}
    
    # Calculate changes for each event
    for event_name, event_date in events.items():
        try:
            # Skip events beyond our data range
            event_date_dt = pd.to_datetime(event_date)
            max_date = df['parsed_date'].max()
            
            # Only process events within our data range
            if event_date_dt <= max_date:
                results[event_name] = calculate_tone_change(df, event_date, window_months)
        except Exception as e:
            print(f"Skipping {event_name} due to: {e}")
    
    # Create DataFrame for heatmap
    all_networks = set()
    for event_data in results.values():
        all_networks.update(event_data.index)
    
    heatmap_data = pd.DataFrame(index=sorted(all_networks), columns=results.keys())
    
    # Fill in heatmap data
    for event_name, event_data in results.items():
        for network in event_data.index:
            heatmap_data.loc[network, event_name] = event_data.loc[network, 'change']
    
    # Plot heatmap
    plt.figure(figsize=(12, 8))
    
    # Choose a colormap that shows positive/negative clearly
    cmap = sns.diverging_palette(220, 10, as_cmap=True)
    
    # Create the heatmap with + and - signs in annotations
    ax = sns.heatmap(heatmap_data, cmap=cmap, center=0, 
               annot=True, fmt=".2f", linewidths=.5, 
               cbar_kws={"shrink": .8})
    
    # Add + signs to positive annotations
    # This is a bit tricky because we need to modify the existing annotations
    for i in range(len(heatmap_data.index)):
        for j in range(len(heatmap_data.columns)):
            text = ax.texts[i * len(heatmap_data.columns) + j]
            value = heatmap_data.iloc[i, j]
            if value > 0:
                text.set_text("+" + text.get_text())
    
    # Add title and labels
    plt.title('News Tone Changes After Major Events (3-Month Window)', fontsize=16, fontweight='bold')
    plt.ylabel('News Network', fontsize=14)
    plt.xlabel('Event', fontsize=14)
    
    # Rotate x-axis labels if needed
    plt.xticks(rotation=30, ha='right')
    
    plt.tight_layout()
    plt.savefig('news_tone_changes_heatmap.png', dpi=300, bbox_inches='tight')
    
    return plt.gcf()

# Example usage:
# plot_tone_change_comparison(df, events)

```

```{python}

plot_tone_change_comparison(df, events)

```

```{python}

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from matplotlib.ticker import MaxNLocator

# Define key event dates - keeping only election events
events = {
    "Trump Election 2016": "2016-11-08",
    "Biden Election 2020": "2020-11-03",
    "Trump Election 2024": "2024-11-05"  # May not be in your dataset yet
}

# Function to calculate average tone before and after an event
def calculate_tone_change(df, event_date, window_months=6):
    """Calculate tone change from before to after an event"""
    # Convert string date to datetime
    event_date = pd.to_datetime(event_date)
    
    # Define time windows
    before_start = event_date - pd.DateOffset(months=window_months)
    after_end = event_date + pd.DateOffset(months=window_months)
    
    # Filter dataframe for the before and after periods
    before_df = df[(df['parsed_date'] >= before_start) & (df['parsed_date'] < event_date)]
    after_df = df[(df['parsed_date'] >= event_date) & (df['parsed_date'] < after_end)]
    
    # Calculate average tone by network before and after
    before_tone = before_df.groupby('network')['tone'].mean()
    after_tone = after_df.groupby('network')['tone'].mean()
    
    # Calculate the difference
    tone_change = pd.DataFrame({
        'before': before_tone,
        'after': after_tone
    })
    
    # Calculate the change
    tone_change['change'] = tone_change['after'] - tone_change['before']
    
    return tone_change

# Function to create a multi-event comparison
def plot_tone_change_comparison(df, events, window_months=6):
    """Create a visualization comparing tone changes across multiple events"""
    results = {}
    
    # Calculate changes for each event
    for event_name, event_date in events.items():
        try:
            # Skip events beyond our data range (like future events)
            event_date_dt = pd.to_datetime(event_date)
            max_date = df['parsed_date'].max()
            
            # Only process events within our data range
            if event_date_dt <= max_date:
                results[event_name] = calculate_tone_change(df, event_date, window_months)
        except Exception as e:
            print(f"Skipping {event_name} due to: {e}")
    
    # Create a figure with subplots
    fig, axes = plt.subplots(len(results), 1, figsize=(14, 4*len(results)), sharex=True)
    
    # If only one event, axes won't be a list
    if len(results) == 1:
        axes = [axes]
    
    # Get all networks for consistent ordering
    all_networks = set()
    for event_data in results.values():
        all_networks.update(event_data.index)
    
    # Sort networks by average change across all events
    network_avg_change = {}
    for network in all_networks:
        changes = []
        for event_data in results.values():
            if network in event_data.index:
                changes.append(event_data.loc[network, 'change'])
        network_avg_change[network] = np.mean(changes) if changes else 0
    
    # Sort networks by average change
    sorted_networks = sorted(network_avg_change.keys(), 
                            key=lambda x: network_avg_change[x])
    
    # Create each subplot
    for i, (event_name, event_data) in enumerate(results.items()):
        ax = axes[i]
        
        # Create a complete dataframe with all networks
        complete_data = pd.DataFrame(index=sorted_networks)
        complete_data['change'] = np.nan
        
        # Fill in available data
        for network in event_data.index:
            complete_data.loc[network, 'change'] = event_data.loc[network, 'change']
        
        # Plot horizontal bars
        colors = [plt.cm.RdBu(0.1) if x < 0 else plt.cm.RdBu(0.9) if x > 0 else 'lightgrey' 
                 for x in complete_data['change']]
        bars = ax.barh(complete_data.index, complete_data['change'], color=colors)
        
        # Add a vertical line at 0
        ax.axvline(x=0, color='black', linestyle='-', alpha=0.3)
        
        # Add title and labels
        ax.set_title(f"{event_name}", fontsize=14, fontweight='bold')
        ax.set_xlabel('Tone Change', fontsize=11)
        
        # Only add y-label for the middle plot
        if i == len(results) // 2:
            ax.set_ylabel('News Network', fontsize=12)
        
        # Add value labels with + or - signs
        for bar in bars:
            width = bar.get_width()
            if not np.isnan(width):  # Only add labels for non-NaN values
                label_x = width + 0.01 if width > 0 else width - 0.01
                alignment = 'left' if width > 0 else 'right'
                # Add + sign for positive values
                sign = "+" if width > 0 else ""
                ax.text(label_x, bar.get_y() + bar.get_height()/2, 
                         f'{sign}{width:.2f}', 
                         ha=alignment, va='center', 
                         color='black', fontweight='bold')
        
        # Add grid
        ax.grid(axis='x', linestyle='--', alpha=0.3)
        
        # Remove top and right spines
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
    
    # Add a common legend to the bottom
    fig.suptitle('News Tone Changes in 6 Months Following Elections', fontsize=16, fontweight='bold', y=0.98)
    fig.text(0.5, 0.01, 'Negative Change = More Negative Coverage   |   Positive Change = More Positive Coverage', 
            ha='center', fontsize=12, fontstyle='italic')
    
    # Adjust layout
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.subplots_adjust(hspace=0.4)
    
    # Save the figure
    plt.savefig('news_tone_changes_6months_after_elections.png', dpi=300, bbox_inches='tight')
    
    return fig

```

```{python}

plot_tone_change_comparison(df, events)

```

rn were seeing that it doesnt matter who wins tone generally gets more positive.

## Key Findings

Based on the statistical analysis and visualizations above, we can observe several key differences in tone across the three news networks:

1. **Overall Tone Comparison**: 
   - [Your interpretation about which network tends to use more positive/negative language]
   - [Your observation about how centered or skewed each network's tone distribution is]

2. **Content Valence Analysis**:
   - [Your analysis of whether networks differ more in their positive or negative language usage]
   - [Your observations about networks that show more extreme tone values in either direction]

3. **Temporal Patterns**:
   - [Your observations about periods where network tone diverges significantly]
   - [Your analysis of any events that coincide with significant tone shifts across networks]

4. **Statistical Significance**:
   - All comparisons between networks show statistically significant differences in tone (p < 0.05).
   - [Your explanation of what might explain these differences in tone between networks]

## Limitations and Future Work

[Discuss any limitations of your analysis and potential future research directions]

# Conclusion

[Summarize your findings and their implications]

# References

[Your references, if applicable]

# Topic Modeling

## Theme Name Mapping

GDELT uses technical theme codes that we convert to more readable names:

```{python}
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from collections import Counter
import seaborn as sns

# Theme name mapping for readability
theme_name_mapping = {
    "LEADER": "Leaders",
    "TAX_FNCACT_PRESIDENT": "Presidents",
    "USPEC_POLITICS_GENERAL1": "General Politics",
    "IMMIGRATION": "Immigration",
    "WB_2769_JOBS_STRATEGIES": "Job Strategies",
    "WB_2837_IMMIGRATION": "Immigration (WB)",
    "WB_2836_MIGRATION_POLICIES_AND_JOBS": "Migration Policies",
    "WB_2670_JOBS": "Jobs",
    "EPU_CATS_MIGRATION_FEAR_MIGRATION": "Migration Fear",
    "GENERAL_GOVERNMENT": "Government",
    "BORDER": "Border",
    "CRISISLEX_CRISISLEXREC": "Crisis Reporting",
    "NATURAL_DISASTER_HURRICANE": "Hurricanes",
    "TAX_WORLDMAMMALS_FOX": "Fox News (Self)",
    "EPU_POLICY_GOVERNMENT": "Government Policy",
    "TAX_FNCACT_POLICE": "Police",
    "UNGP_CRIME_VIOLENCE": "Crime & Violence",
    "HEALTH_VACCINATION": "Vaccination",
    "WB_639_REPRODUCTIVE_MATERNAL_AND_CHILD_HEALTH": "Reproductive & Child Health",
    "WB_642_CHILD_HEALTH": "Child Health",
    "WB_1459_IMMUNIZATIONS": "Immunizations",
    "UNGP_HEALTHCARE": "Healthcare (UNGP)",
    "TAX_FNCACT_NOMINEE": "Nominees",
    "MEDIA_SOCIAL": "Social Media",
    "ELECTION": "Election",
    "ECON_INFLATION": "Inflation",
    "WB_1104_MACROECONOMIC_VULNERABILITY_AND_DEBT": "Macro Vulnerability & Debt",
    "WB_442_INFLATION": "Inflation (WB)",
    "TAX_POLITICAL_PARTY_DEMOCRATS": "Democrats",
    "TAX_FNCACT_QUEEN": "Queen",
    "TAX_FNCACT_VICE_PRESIDENT": "Vice Presidents",
    "CRISISLEX_C07_SAFETY": "Safety",
    "MANMADE_DISASTER_IMPLIED": "Manmade Disaster",
    "WB_2432_FRAGILITY_CONFLICT_AND_VIOLENCE": "Conflict & Fragility"
}
```

```{python}
# Function to process themes and get top N themes by network
def get_top_themes_by_network(df, n=10):
    # Group by network
    networks = df['network'].unique()
    results = {}
    
    for network in networks:
        network_df = df[df['network'] == network]
        
        # Drop missing themes and split by semicolon
        themes_series = network_df["V2Themes"].dropna().str.split(";")
        
        # Flatten the list of all theme entries
        all_themes = [theme.split(",")[0] for sublist in themes_series for theme in sublist if theme]
        
        # Count the most frequent themes
        theme_counts = Counter(all_themes).most_common(n)
        
        # Map to friendly names
        friendly_counts = [(theme_name_mapping.get(theme, theme), count) for theme, count in theme_counts]
        
        # Store in results
        results[network] = friendly_counts
    
    return results

# Function to create a single plot with top themes for all networks
def plot_top_themes_by_network(df, n=10):
    themes_by_network = get_top_themes_by_network(df, n)
    
    # Get all unique themes across networks
    all_themes = set()
    for network, themes in themes_by_network.items():
        all_themes.update([theme for theme, _ in themes])
    
    # Create a DataFrame for plotting
    plot_data = []
    for network, themes in themes_by_network.items():
        for theme, count in themes:
            plot_data.append({
                'Network': network,
                'Theme': theme,
                'Count': count
            })
    
    plot_df = pd.DataFrame(plot_data)
    
    # Create the plot
    plt.figure(figsize=(15, 10))
    
    # Use different color for each network
    networks = plot_df['Network'].unique()
    colors = sns.color_palette("viridis", len(networks))
    network_colors = {network: color for network, color in zip(networks, colors)}
    
    # Plot each network as a grouped bar
    ax = sns.barplot(
        data=plot_df,
        x='Theme', 
        y='Count',
        hue='Network',
        palette=network_colors,
        alpha=0.8
    )
    
    # Customize plot appearance
    plt.title("Top 10 Themes Across News Networks", fontsize=18, fontweight='bold')
    plt.xlabel('Theme', fontsize=14)
    plt.ylabel('Frequency', fontsize=14)
    plt.xticks(rotation=45, ha='right', fontsize=12)
    plt.legend(title='Network', fontsize=12, title_fontsize=14)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    
    # Add value annotations
    for container in ax.containers:
        ax.bar_label(container, fmt='%.0f', fontsize=10)
    
    plt.tight_layout()
    plt.savefig('top_themes_by_network.png', dpi=300, bbox_inches='tight')
    plt.show()

# Alternative visualization: Heatmap of top themes by network
def plot_themes_heatmap(df, n=10):
    themes_by_network = get_top_themes_by_network(df, n)
    
    # Get all unique themes across networks
    all_themes = set()
    for network, themes in themes_by_network.items():
        all_themes.update([theme for theme, _ in themes])
    
    # Create a DataFrame for the heatmap
    heatmap_data = pd.DataFrame(0, 
                              index=sorted(list(all_themes)),
                              columns=sorted(list(themes_by_network.keys())))
    
    # Fill in the heatmap data
    for network, themes in themes_by_network.items():
        for theme, count in themes:
            heatmap_data.loc[theme, network] = count
    
    # Sort rows by total frequency
    heatmap_data['Total'] = heatmap_data.sum(axis=1)
    heatmap_data = heatmap_data.sort_values('Total', ascending=False).drop('Total', axis=1)
    
    # Keep only top 15 themes for readability
    heatmap_data = heatmap_data.head(15)
    
    # Create the heatmap
    plt.figure(figsize=(14, 10))
    
    # Create a mask for zero values (optional)
    mask = heatmap_data == 0
    
    # Plot the heatmap
    sns.heatmap(heatmap_data, annot=True, fmt=".0f", cmap="viridis", 
                linewidths=.5, cbar_kws={"label": "Frequency"},
                mask=mask)
    
    plt.title("Top Themes Coverage by News Network", fontsize=18, fontweight='bold')
    plt.ylabel('Theme', fontsize=14)
    plt.xlabel('News Network', fontsize=14)
    plt.tight_layout()
    plt.savefig('themes_heatmap.png', dpi=300, bbox_inches='tight')
    plt.show()

# Example usage (assumes df is your dataframe with network and V2Themes columns):
# plot_top_themes_by_network(df, 10)
# plot_themes_heatmap(df, 10)

# If you prefer a more compact stacked bar chart by theme:
def plot_stacked_theme_bars(df, n=10):
    themes_by_network = get_top_themes_by_network(df, n)
    
    # Get top overall themes
    all_theme_counts = Counter()
    for network, themes in themes_by_network.items():
        for theme, count in themes:
            all_theme_counts[theme] += count
    
    top_themes = [theme for theme, _ in all_theme_counts.most_common(n)]
    
    # Create a DataFrame for plotting
    plot_data = []
    for network, themes in themes_by_network.items():
        theme_dict = {theme: count for theme, count in themes}
        for theme in top_themes:
            plot_data.append({
                'Network': network,
                'Theme': theme,
                'Count': theme_dict.get(theme, 0)
            })
    
    plot_df = pd.DataFrame(plot_data)
    
    # Pivot for stacked bar chart
    pivot_df = plot_df.pivot(index='Theme', columns='Network', values='Count')
    
    # Sort by total mentions across networks
    pivot_df['Total'] = pivot_df.sum(axis=1)
    pivot_df = pivot_df.sort_values('Total', ascending=False)
    pivot_df = pivot_df.drop('Total', axis=1)
    
    # Plot
    ax = pivot_df.plot(kind='barh', stacked=True, figsize=(14, 10), 
                      colormap='viridis', width=0.8)
    
    # Add total value annotations
    for i, (theme, row) in enumerate(pivot_df.iterrows()):
        total = row.sum()
        ax.text(total + (total * 0.01), i, f'{total:,.0f}', 
                va='center', ha='left', fontweight='bold', color='dimgrey')
    
    plt.title("Top 10 Themes Across News Networks", fontsize=18, fontweight='bold')
    plt.xlabel('Frequency', fontsize=14)
    plt.grid(axis='x', linestyle='--', alpha=0.7)
    plt.legend(title='Network', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.savefig('top_themes_stacked.png', dpi=300, bbox_inches='tight')
    plt.show()

plot_stacked_theme_bars(df, 10) 

```

### printing how topics changed before and after major events like elections and covid

```{python}

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from collections import Counter
from matplotlib.ticker import MaxNLocator

# Theme name mapping for readability (same as in your code)
theme_name_mapping = {
    "LEADER": "Leaders",
    "TAX_FNCACT_PRESIDENT": "Presidents",
    "USPEC_POLITICS_GENERAL1": "General Politics",
    "IMMIGRATION": "Immigration",
    "WB_2769_JOBS_STRATEGIES": "Job Strategies",
    "WB_2837_IMMIGRATION": "Immigration (WB)",
    "WB_2836_MIGRATION_POLICIES_AND_JOBS": "Migration Policies",
    "WB_2670_JOBS": "Jobs",
    "EPU_CATS_MIGRATION_FEAR_MIGRATION": "Migration Fear",
    "GENERAL_GOVERNMENT": "Government",
    "BORDER": "Border",
    "CRISISLEX_CRISISLEXREC": "Crisis Reporting",
    "NATURAL_DISASTER_HURRICANE": "Hurricanes",
    "TAX_WORLDMAMMALS_FOX": "Fox News (Self)",
    "EPU_POLICY_GOVERNMENT": "Government Policy",
    "TAX_FNCACT_POLICE": "Police",
    "UNGP_CRIME_VIOLENCE": "Crime & Violence",
    "HEALTH_VACCINATION": "Vaccination",
    "WB_639_REPRODUCTIVE_MATERNAL_AND_CHILD_HEALTH": "Reproductive & Child Health",
    "WB_642_CHILD_HEALTH": "Child Health",
    "WB_1459_IMMUNIZATIONS": "Immunizations",
    "UNGP_HEALTHCARE": "Healthcare (UNGP)",
    "TAX_FNCACT_NOMINEE": "Nominees",
    "MEDIA_SOCIAL": "Social Media",
    "ELECTION": "Election",
    "ECON_INFLATION": "Inflation",
    "WB_1104_MACROECONOMIC_VULNERABILITY_AND_DEBT": "Macro Vulnerability & Debt",
    "WB_442_INFLATION": "Inflation (WB)",
    "TAX_POLITICAL_PARTY_DEMOCRATS": "Democrats",
    "TAX_FNCACT_QUEEN": "Queen",
    "TAX_FNCACT_VICE_PRESIDENT": "Vice Presidents",
    "CRISISLEX_C07_SAFETY": "Safety",
    "MANMADE_DISASTER_IMPLIED": "Manmade Disaster",
    "WB_2432_FRAGILITY_CONFLICT_AND_VIOLENCE": "Conflict & Fragility"
}

# Define election dates
elections = {
    "Trump Election 2016": "2016-11-08",
    "Biden Election 2020": "2020-11-03",
    "Trump Election 2024": "2024-11-05"  # May not be in dataset yet
}

def get_top_themes_by_period(df, start_date, end_date, n=1):
    """
    Get top N themes for a specific time period
    """
    # Filter data for time period
    period_df = df[(df['parsed_date'] >= start_date) & (df['parsed_date'] < end_date)]
    
    # Drop missing themes and split by semicolon
    themes_series = period_df["V2Themes"].dropna().str.split(";")
    
    # Flatten the list of all theme entries
    all_themes = [theme.split(",")[0] for sublist in themes_series for theme in sublist if theme]
    
    # Count the most frequent themes
    theme_counts = Counter(all_themes).most_common(n)
    
    # Map to friendly names
    friendly_counts = [(theme_name_mapping.get(theme, theme), count) for theme, count in theme_counts]
    
    return friendly_counts

def get_top_themes_by_network_and_period(df, start_date, end_date, n=1):
    """
    Get top themes by network for a specific time period
    """
    # Filter data for time period
    period_df = df[(df['parsed_date'] >= start_date) & (df['parsed_date'] < end_date)]
    
    # Group by network
    networks = period_df['network'].unique()
    results = {}
    
    for network in networks:
        network_df = period_df[period_df['network'] == network]
        
        # Drop missing themes and split by semicolon
        themes_series = network_df["V2Themes"].dropna().str.split(";")
        
        # Flatten the list of all theme entries
        all_themes = [theme.split(",")[0] for sublist in themes_series for theme in sublist if theme]
        
        # Count the most frequent themes
        theme_counts = Counter(all_themes).most_common(n)
        
        # Map to friendly names
        friendly_counts = [(theme_name_mapping.get(theme, theme), count) for theme, count in theme_counts]
        
        # Store in results
        results[network] = friendly_counts
    
    return results

def compare_top_themes_before_after_election(df, election_date, window_months=3, n_themes=1):
    """
    Compare top themes before and after an election
    """
    # Convert string date to datetime
    election_date = pd.to_datetime(election_date)
    
    # Define time windows
    before_start = election_date - pd.DateOffset(months=window_months)
    before_end = election_date
    after_start = election_date
    after_end = election_date + pd.DateOffset(months=window_months)
    
    # Get top themes by network before and after
    before_themes = get_top_themes_by_network_and_period(df, before_start, before_end, n_themes)
    after_themes = get_top_themes_by_network_and_period(df, after_start, after_end, n_themes)
    
    return before_themes, after_themes

def plot_top_theme_comparison(df, elections, window_months=3, n_themes=1):
    """
    Create a visualization comparing top theme before vs after elections
    """
    results = {}
    
    # Calculate themes for each election
    for election_name, election_date in elections.items():
        try:
            # Skip elections beyond our data range
            election_date_dt = pd.to_datetime(election_date)
            max_date = df['parsed_date'].max()
            
            # Only process elections within our data range
            if election_date_dt <= max_date:
                before_themes, after_themes = compare_top_themes_before_after_election(
                    df, election_date, window_months, n_themes)
                results[election_name] = (before_themes, after_themes)
        except Exception as e:
            print(f"Skipping {election_name} due to: {e}")
    
    # Create the visualization
    n_elections = len(results)
    fig, axes = plt.subplots(n_elections, 1, figsize=(14, 5*n_elections))
    
    # If only one election, make axes a list
    if n_elections == 1:
        axes = [axes]
    
    # For each election
    for i, (election_name, (before_themes, after_themes)) in enumerate(results.items()):
        ax = axes[i]
        
        # Create data for plot
        networks = sorted(set(before_themes.keys()) | set(after_themes.keys()))
        
        data = []
        for network in networks:
            # Get themes before and after (default to None if missing)
            before_theme = before_themes.get(network, [("No Data", 0)])[0][0]
            after_theme = after_themes.get(network, [("No Data", 0)])[0][0]
            
            data.append({
                'Network': network,
                'Before Election': before_theme,
                'After Election': after_theme
            })
        
        # Convert to DataFrame
        df_plot = pd.DataFrame(data)
        
        # Create a table
        table_data = [[network, before, after] for network, before, after in 
                     zip(df_plot['Network'], df_plot['Before Election'], df_plot['After Election'])]
        
        # Create the table
        table = ax.table(cellText=table_data,
                         colLabels=['News Network', '3 Months Before', '3 Months After'],
                         loc='center',
                         cellLoc='center')
        
        # Customize table
        table.auto_set_font_size(False)
        table.set_fontsize(10)
        table.scale(1, 1.5)
        
        # Color cells where the topic changed
        for row_idx, row in enumerate(table_data):
            if row[1] != row[2]:  # If before != after
                table[(row_idx+1, 1)].set_facecolor('#ffcccc')  # Light red for before
                table[(row_idx+1, 2)].set_facecolor('#ccffcc')  # Light green for after
        
        # Remove axes ticks and spines
        ax.set_xticks([])
        ax.set_yticks([])
        for spine in ax.spines.values():
            spine.set_visible(False)
        
        # Add title
        ax.set_title(f"Top Topic Before vs After {election_name}", fontsize=16, fontweight='bold', pad=20)
    
    plt.tight_layout()
    plt.subplots_adjust(hspace=0.5)
    
    # Save figure
    plt.savefig('top_themes_before_after_elections.png', dpi=300, bbox_inches='tight')
    
    return fig

# Alternative visualization - bar chart showing topic transitions
def plot_topic_transitions(df, elections, window_months=3, n_themes=1):
    """
    Create a visualization showing topic transitions before and after elections
    """
    all_results = {}
    
    # Calculate themes for each election
    for election_name, election_date in elections.items():
        try:
            # Skip elections beyond our data range
            election_date_dt = pd.to_datetime(election_date)
            max_date = df['parsed_date'].max()
            
            # Only process elections within our data range
            if election_date_dt <= max_date:
                before_themes, after_themes = compare_top_themes_before_after_election(
                    df, election_date, window_months, n_themes)
                all_results[election_name] = (before_themes, after_themes)
        except Exception as e:
            print(f"Skipping {election_name} due to: {e}")
    
    # Create a figure with subplots
    n_elections = len(all_results)
    fig, axes = plt.subplots(n_elections, 1, figsize=(16, 6*n_elections))
    
    # If only one election, make axes a list
    if n_elections == 1:
        axes = [axes]
    
    # For each election
    for i, (election_name, (before_themes, after_themes)) in enumerate(all_results.items()):
        ax = axes[i]
        
        # Create data for visualization
        networks = sorted(set(before_themes.keys()) | set(after_themes.keys()))
        
        # Prepare data for plotting
        plot_data = []
        for j, network in enumerate(networks):
            # Get before theme and count
            if network in before_themes:
                before_theme, before_count = before_themes[network][0]
            else:
                before_theme, before_count = "No Data", 0
            
            # Get after theme and count
            if network in after_themes:
                after_theme, after_count = after_themes[network][0]
            else:
                after_theme, after_count = "No Data", 0
            
            # Add data point
            plot_data.append({
                'Network': network,
                'Position': 'Before',
                'Theme': before_theme,
                'Count': before_count
            })
            
            plot_data.append({
                'Network': network,
                'Position': 'After',
                'Theme': after_theme,
                'Count': after_count
            })
        
        # Convert to DataFrame
        plot_df = pd.DataFrame(plot_data)
        
        # Set up colors
        unique_themes = plot_df['Theme'].unique()
        colors = plt.cm.tab20(np.linspace(0, 1, len(unique_themes)))
        theme_colors = {theme: color for theme, color in zip(unique_themes, colors)}
        
        # Plot
        positions = ['Before', 'After']
        
        # For each network
        for j, network in enumerate(networks):
            network_data = plot_df[plot_df['Network'] == network]
            
            # X positions for this network
            x_pos = [j*3, j*3 + 1]
            
            # Plot bars
            for k, (idx, row) in enumerate(network_data.iterrows()):
                color = theme_colors[row['Theme']]
                ax.bar(x_pos[k], row['Count'], color=color, width=0.8, 
                       alpha=0.7, label=row['Theme'] if row['Theme'] not in ax.get_legend_handles_labels()[1] else "")
                
                # Add theme label
                ax.text(x_pos[k], row['Count']/2, row['Theme'], ha='center', va='center', 
                        fontsize=9, fontweight='bold', rotation=90, color='black')
                
                # Add "Before" or "After" label
                ax.text(x_pos[k], -max(plot_df['Count'])*0.05, row['Position'], 
                        ha='center', va='top', fontsize=8)
            
            # Add network label
            ax.text(j*3 + 0.5, -max(plot_df['Count'])*0.12, network, 
                    ha='center', va='top', fontsize=10, fontweight='bold')
            
            # If theme changed, add arrow
            before_theme = network_data[network_data['Position'] == 'Before']['Theme'].values[0]
            after_theme = network_data[network_data['Position'] == 'After']['Theme'].values[0]
            
            if before_theme != after_theme:
                ax.annotate("", xy=(x_pos[1], max(plot_df['Count'])*0.8), 
                           xytext=(x_pos[0], max(plot_df['Count'])*0.8),
                           arrowprops=dict(arrowstyle="->", color='red', lw=2))
        
        # Set up axis
        ax.set_xticks([])
        ax.set_title(f"Top Topic Shifts After {election_name}", fontsize=16, fontweight='bold')
        ax.set_ylabel('Frequency', fontsize=12)
        
        # Add a legend for themes
        handles, labels = ax.get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        ax.legend(by_label.values(), by_label.keys(), loc='upper right', 
                  bbox_to_anchor=(1.15, 1), fontsize=10, title="Themes")
        
        # Add grid
        ax.grid(axis='y', linestyle='--', alpha=0.3)
    
    plt.tight_layout()
    plt.subplots_adjust(hspace=0.3)
    
    # Save figure
    plt.savefig('top_topic_transitions.png', dpi=300, bbox_inches='tight')
    
    return fig
```

```{python}

# plot_top_theme_comparison(df, elections)
plot_topic_transitions(df, elections)

```